using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[RequireComponent(typeof(Rigidbody))]
[RequireComponent(typeof(MeshCollider))]
public class SubFracture : MonoBehaviour
{
    FractureNetworkNode node;

    //get component references
    Rigidbody _rb;

    MeshCollider _collider;

    public FractureNetwork _network;

    public FractureNetworkNode _node;

    void Start()
    {
        _network = GetComponentInParent<FractureNetwork>(); //get fracture network

        _rb = GetComponent<Rigidbody>();        //get rigid body or create one if none exists
        if (!_rb)
        {
            _rb = gameObject.AddComponent<Rigidbody>();
        }


        
        _rb.isKinematic = true; //turn off physics until broken

        
        _collider = GetComponent<MeshCollider>();//add collider if none exists
        if (!_collider)
        {
            _collider = gameObject.AddComponent<MeshCollider>();
            //collider should be convex for complex subfractures
            //like those generated by voronoi fracture
            //if you have a fractured mesh it is likely the pieces will be convex
            _collider.convex = true;
        }


    }

    private void Update()
    {
        Break();
    }

    public void Break()
    {
        if (_node.isBroken)
        {
            _rb.isKinematic = false;
            _node.isBroken = true; //don't use this node for future pathfinding

            //_network.network.Remove(_node); //this node will not check for grounding or play any part in structural evaluation

            foreach (FractureNetworkNode node in _node.neighbours) //remove from neighbors' neighbour list, optimizes further pathfinding
            {
                node.neighbours.Remove(_node);
            }

            _node.neighbours.Clear(); //clear this node's neighbours
            gameObject.GetComponent<MeshRenderer>().material.color = Color.red; //set mesh to red if broken
        }  
    }

    private void OnCollisionEnter(Collision collision)
    {
        if(_node.isBroken) return;
        if (collision == null) return;
        //if (_node.isFoundation) return;

        if (collision.impulse.magnitude >2.5f) //if collision is of sufficient force
        {
            _node.isBroken = true;
            _network.StartCollapse(); //if the fractured mesh is not already collapsing, start collapsing
        }
        

    }


}
